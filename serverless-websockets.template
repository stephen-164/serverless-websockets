# A template that creates a service for hosting WebSocket connections to browsers
#
# Copyright 2017 Melon Software Ltd (UK), all rights reserved.  Provided under the MIT License.
#
---
AWSTemplateFormatVersion: '2010-09-09'
Description: "Creates a service for hosting WebSocket connections to browsers"

Parameters:
    # Environment name
    Environment:
        Type: "String"
        Description: "The name of the environment"

Resources:

    IamRoleLambdaExecution:
        Type: "AWS::IAM::Role"
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                  - Effect: "Allow"
                    Principal: { Service: [ "lambda.amazonaws.com" ] }
                    Action:
                      - "sts:AssumeRole"
            ManagedPolicyArns:
              - "arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"
            Policies:
              - PolicyName: "iotaccess"
                PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Effect: "Allow"
                        Action:
                          - "iot:DescribeEndpoint"
                          - "sts:AssumeRole"
                        Resource: "*"
            RoleName: "serverless-websockets-lambda"

    # This is the role that clients will assume to actually use the IoT webhooks
    IamRoleIotAccess:
        Type: "AWS::IAM::Role"
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                  - Effect: "Allow"
                    # The Lambda function assumes the role and generates the STS keys, then passes them to the client.
                    # As far as AWS is concerned, the Lambda function is doing all the work.
                    Principal: { AWS: { "Fn::Sub": "arn:aws:sts::${AWS::AccountId}:role/${IamRoleLambdaExecution}" } }
                    Action:
                      - "sts:AssumeRole"
            Policies:
              - PolicyName: "consumer"
                PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Effect: "Allow"
                        Action:
                            # You'll need to add "iot:Publish" both here and in the Lambda function below, if you want
                            # your clients to be able to publish to the stream as well as read from it.
                          - "iot:Connect"
                          - "iot:Subscribe"
                          - "iot:Receive"
                        Resource: "*"
            RoleName: "serverless-websockets-client"

    AuthLambdaFunction:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: |
                    # Provide STS credentials to allow web clients to access the IoT service and subscribe to topics using WebHooks.
                    #
                    # Copyright 2017 Melon Software Ltd (UK), all rights reserved.  Provided under the MIT License.
                    import json
                    import random
                    import logging
                    import boto3

                    logger = logging.getLogger()
                    logger.setLevel(logging.INFO)


                    def handler(event, context):
                        logger.info(json.dumps(event, sort_keys=True, indent=4))

                        # First you'll want to authenticate your clients using information that they've sent in the request.  You could
                        # use a JWT claim that is generated by your application and can then be validated here without needing to access
                        # any stateful resources.

                        # get the endpoint address
                        iot_client = boto3.client('iot')

                        iot_endpoint = iot_client.describe_endpoint()

                        # The current structure of the IoT endpoint is "<random>.iot.<region>.amazonaws.com"
                        region = iot_endpoint['endpointAddress'].split('.')[2]

                        # get the AWS account ID
                        sts_client = boto3.client('sts')
                        aws_account_id = sts_client.get_caller_identity()['Account']

                        # You might want to change this to a more meaningful ID if your users have them, but remember that the ID must be
                        # unique amongst all connecting devices: if a user tries to connect with the same client ID on multiple devices,
                        # the oldest connection will be terminated.
                        client_id = '%0x' % random.getrandbits(8 * 4)

                        # The permissions of the Assumed Role credentials are the intersection of the Role itself, and this policy; we use
                        # this to lock the credentials down to the topic that the client originally requested.  You'll want to change this
                        # to match your application's requirements, not just "all topics matching 'allowed/*'".
                        policy = {
                            "Version": "2012-10-17",
                            "Statement": [
                                {
                                    "Sid": "connect",
                                    "Action": ["iot:Connect", "iot:Subscribe", "iot:Receive"],
                                    "Resource": [
                                        "arn:aws:iot:us-east-1:%s:client/%s" % (aws_account_id, client_id),
                                        "arn:aws:iot:us-east-1:%s:topicfilter/allowed/*" % aws_account_id,
                                        "arn:aws:iot:us-east-1:%s:topic/allowed/*" % aws_account_id
                                    ],
                                    "Effect": "Allow"
                                }
                            ]
                        }

                        # assume role returns temporary keys
                        assume_role_credentials = sts_client.assume_role(
                            RoleArn="arn:aws:iam::%s:role/%s" % (aws_account_id, 'serverless-websockets-client'),
                            RoleSessionName=client_id,
                            Policy=json.dumps(policy)
                        )

                        return {
                            "statusCode": 200,
                            "headers": {"Access-Control-Allow-Origin": "*"},
                            "body": json.dumps({
                                "iotEndpoint": iot_endpoint['endpointAddress'],
                                "region": region,
                                "clientId": client_id,
                                "accessKey": assume_role_credentials['Credentials']['AccessKeyId'],
                                "secretKey": assume_role_credentials['Credentials']['SecretAccessKey'],
                                "sessionToken": assume_role_credentials['Credentials']['SessionToken']
                            })
                        }

            FunctionName: "serverless-websockets-authentication"
            Handler: "index.handler"
            MemorySize: "128"
            Role: { "Fn::GetAtt": [ "IamRoleLambdaExecution", "Arn" ] }
            Runtime: "python2.7"
            Timeout: "30"

    ApiGatewayRestApi:
        Type: "AWS::ApiGateway::RestApi"
        Properties:
            Name: { "Fn::Sub": "serverless-websockets-${Environment}" }

    ApiGatewayResourceIotKeys:
        Type: "AWS::ApiGateway::Resource"
        Properties:
            ParentId: { "Fn::GetAtt": [ "ApiGatewayRestApi", "RootResourceId" ] }
            PathPart: "iotkeys"
            RestApiId: { Ref: "ApiGatewayRestApi" }

    ApiGatewayMethodIotKeysMethod:
        Type: "AWS::ApiGateway::Method"
        Properties:
            HttpMethod: "POST"
            ResourceId: { Ref: "ApiGatewayResourceIotKeys" }
            RestApiId: { Ref: "ApiGatewayRestApi" }
            AuthorizationType: "NONE"
            Integration:
                IntegrationHttpMethod: "POST"
                Type: "AWS_PROXY"
                Uri: { "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AuthLambdaFunction.Arn}/invocations" }

    ApiGatewayDeployment:
        Type: "AWS::ApiGateway::Deployment"
        Properties:
            RestApiId: { Ref: "ApiGatewayRestApi" }
            StageName: { Ref: "Environment" }
        DependsOn:
          - "ApiGatewayMethodIotKeysMethod"

    # Allow the API Gateway to execute the Lambda Function
    AuthLambdaPermissionApiGateway:
        Type: "AWS::Lambda::Permission"
        Properties:
            FunctionName: { "Fn::GetAtt": [ "AuthLambdaFunction", "Arn" ] }
            Action: "lambda:InvokeFunction"
            Principal: "apigateway.amazonaws.com"
            SourceArn: { "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*" }

Outputs:
    ServiceEndpoint:
        Description: "URL of the service endpoint"
        Value: { "Fn::Sub": "https://${ApiGatewayRestApi}.execute-api.us-east-1.amazonaws.com/${Environment}" }
